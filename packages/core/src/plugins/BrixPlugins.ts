import { Config } from '../config';
import { BrixConfigPlugin } from '../config/types';
import { ErrorPluginRegistered, ErrorPluginsNotBuilt, ErrorPluginUnknown, ErrorRequiredPluginMissing, ErrorPluginNotAFunction } from '../errors';
import { logger } from '../lib/logger';
import { importLib } from '../lib/resolveFrom';
import { ClassType, ScalarsTypeMap } from './types';
import stack from 'stack-trace';
import findRoot from 'find-root';


/**
 * Options for registering a plugin with Brix
 */
export interface BrixPluginOptions {
  /** Pretty name of the Brix plugin */
  name: string;
  /** Description of the Brix plugin */
  description?: string;
  /** List of other Brix plugins this plugin relies on */
  requires?: string[];
  /** GQL Entities to register in Brix */
  entities?: ClassType<any>[];
  /** GQL Scalars to register in Brix */
  scalars?: ScalarsTypeMap[];
  /** GQL Resolvers to register in Brix */
  resolvers?: ClassType<any>[];
}
export interface BrixPluginSettings extends BrixPluginOptions {
  package: string;
}

export interface BrixPluginData {
  /** Array of GQL Entities */
  entities: ClassType<any>[];
  /** Array of GQL Scalars */
  scalars: ScalarsTypeMap[];
  /** Array of GQL Resolvers */
  resolvers: ClassType<any>[];
}

export type PluginPkg = (options?: any) => any;


/**
 * Brix plugin management
 */
export abstract class BrixPlugins {
  /** Array of GQL Entities */
  static get entities() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.entities;
  }
  /** Array of GQL Scalars */
  static get resolvers() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.resolvers;
  }
  /** Array of GQL Resolvers */
  static get scalars() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.scalars;
  }
  private static _plugins: { [name: string]: BrixPluginSettings } = {};
  private static _buildData?: BrixPluginData;


  /**
  * Register a Brix plugin
  * @param options Options for the Brix plugin
  * @example
  *  registerPlugin({
  *    name: 'cms',
  *    resolvers: [...],
  *    scalars: [{...}]
  *  })
  */
  static register(options: BrixPluginOptions) {
    const calledFrom = stack.get()[1].getFileName();
    const root = findRoot(calledFrom);
    const pkg: string = require(`${root}/package.json`).name;

    if (this._plugins[pkg]) throw new ErrorPluginRegistered(options.name);
    else {
      this._plugins[pkg] = {
        package: pkg,
        ...options
      };
    }
  }

  /**
   * Perform checks on plugins and return all entities, resolvers, scalars, etc
   * generated by the plugin ecosystem
   */
  static async build() {
    if (this._buildData) return this._buildData;
    await Config.loadConfig();

    const attemptLoad = (pkg: string): Promise<false | PluginPkg> => new Promise(async res => {
      try {
        res(await importLib(pkg));
      } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') res(false);
        else throw e;
      }
    });

    await Promise.all(Config.plugins.map(async p => {
      const plugin = this.formatPlugin(p);
      let pkg;
      if (!pkg) pkg = await attemptLoad(`@brix/${plugin.name}`);
      if (!pkg) pkg = await attemptLoad(`@brix/plugin-${plugin.name}`);
      if (!pkg) pkg = await attemptLoad(`brix-plugin-${plugin.name}`);
      if (!pkg) pkg = await attemptLoad(plugin.name);
      if (!pkg) throw new ErrorPluginUnknown(plugin.name);
      if (typeof pkg !== 'function') throw new ErrorPluginNotAFunction(plugin.name);
      await (pkg as PluginPkg)(p.options);
    }));

    this._checkRequired();

    Object.keys(this._plugins).map(n => logger.info(`Loaded plugin ${n}`));

    return this._buildData = {
      entities: this._getEntities(),
      resolvers: this._getResolvers(),
      scalars: this._getScalars()
    };
  }

  /**
   * Loop over all plugins and check that the dependencies are installed
   */
  private static _checkRequired() {
    Object.values(this._plugins).forEach(p => {
      if (!p.requires) return;
      p.requires.forEach(required => {
        // TODO: Install required plugin automatically
        if (!this._plugins[required]) throw new ErrorRequiredPluginMissing(p.package, required);
      });
    });

    return true;
  }


  /** * Retrieve all entities from registered plugins */
  private static _getEntities() {
    return this._get('entities')!;
  }

  /** * Retrieve all resolvers from registered plugins */
  private static _getResolvers() {
    return this._get('resolvers')!;
  }

  /** * Retrieve all scalars from registered plugins */
  private static _getScalars() {
    return this._get('scalars')!;
  }

  /**
   * Combines a key from all plugins
   * @param from Key from each plugin to retrieve
   */
  private static _get<T extends keyof BrixPluginOptions>(from: T) {
    return Object.values(this._plugins).reduce((list, plugin) => {
      if (plugin[from]) return (list as any).concat(plugin[from]);
      return list;
    }, [] as unknown as BrixPluginOptions[T]);
  }

  private static formatPlugin(p: BrixConfigPlugin | string): BrixConfigPlugin {
    if (typeof p === 'string') return { name: p, options: {} };
    return p;
  }
}
