import chalk from 'chalk';
import findRoot from 'find-root';
import path from 'path';
import stack from 'stack-trace';

import { Config } from '../config';
import {
  ErrorPluginNotAFunction,
  ErrorPluginRegistered,
  ErrorPluginsNotBuilt,
  ErrorPluginUnknown,
  ErrorRequiredPluginMissing,
} from '../errors';
import { installHandler } from '../lib/installPlugin';
import { logger } from '../lib/logger';
import { importLib } from '../lib/resolveFrom';
import { BrixPluginData, BrixPluginOptions, BrixPluginSettings, PluginPkg } from './types';


/**
 * Brix plugin management
 */
export abstract class BrixPlugins {
  // /** Array of GQL Entities */
  // static get entities() {
  //   if (!this._buildData) throw new ErrorPluginsNotBuilt();
  //   return this._buildData.entities;
  // }
  /** Array of GQL Scalars */
  static get resolvers() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.resolvers;
  }
  /** Array of GQL Resolvers */
  static get scalars() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.scalars;
  }
  /** Array of Express middlewares */
  static get middlewares() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.middlewares;
  }
  /** Array of Apollo context middlewares */
  static get contextMiddlewares() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.contextMiddlewares;
  }
  /** Array of BrixAuthCheckers to use in `type-graphql` */
  static get authCheckers() {
    if (!this._buildData) throw new ErrorPluginsNotBuilt();
    return this._buildData.authCheckers;
  }
  private static _plugins: { [name: string]: BrixPluginSettings } = {};
  private static _buildData?: BrixPluginData;
  private static _building: null | Promise<BrixPluginData> = null;


  /**
  * Register a Brix plugin
  * @param options Options for the Brix plugin
  * @param overridePackage Use the `options.name` as the package registry
  * @example
  *  registerPlugin({
  *    name: 'cms',
  *    resolvers: [...],
  *    scalars: [{...}]
  *  })
  */
  static register(options: BrixPluginOptions, overridePackage = false) {
    const calledFrom = stack.get()[1].getFileName();
    const root = findRoot(calledFrom);
    let pkg: string;
    const pkgName = options.name.replace(/\s/g, '-').toLowerCase();
    if (overridePackage) pkg = pkgName;
    else pkg = require(`${root}/package.json`).name;
    if (!pkg) pkg = pkgName;

    if (this._plugins[pkg]) throw new ErrorPluginRegistered(options.name);
    else {
      this._plugins[pkg] = {
        package: pkg,
        ...options
      };
    }
  }

  /**
   * Perform checks on plugins and return all entities, resolvers, scalars, etc
   * generated by the plugin ecosystem
   */
  static async build() {
    if (this._buildData) return this._buildData;
    if (this._building) return this._building;

    return this._building = new Promise(async (res, rej) => {
      await Config.loadConfig();

      const attemptLoad = (pkg: string): Promise<false | PluginPkg> => new Promise(async res => {
        try {
          res(await importLib(pkg));
        } catch (e) {
          if (e.code === 'MODULE_NOT_FOUND') res(false);
          else throw e;
        }
      });

      const uninstalled: [string, any][] = [];

      const loadPlugins = (plugins: [string, any][], second = false) => Promise.all(
        plugins.map(async ([p, options]) => {
          let pkg;
          if (p.startsWith('./')) pkg = await attemptLoad(path.join(Config.rootDir, p));
          if (!pkg) pkg = await attemptLoad(`@brix/${p}`);
          if (!pkg) pkg = await attemptLoad(`@brix/plugin-${p}`);
          if (!pkg) pkg = await attemptLoad(`brix-plugin-${p}`);
          if (!pkg) pkg = await attemptLoad(p);
          if (!pkg) {
            if (Config.installPlugins && !second) return uninstalled.push([p, options]);
            return rej(new ErrorPluginUnknown(p));
          }
          if (typeof pkg !== 'function') throw new ErrorPluginNotAFunction(p);
          await (pkg as PluginPkg)(options || undefined);
          logger.info(`Loaded plugin ${p}`);
        })
      );

      if (Config.plugins) {
        try {
          // 1. Attempt to load all plugins, and collect uninstalled
          await loadPlugins(Object.entries(Config.plugins));
          if (Config.installPlugins && uninstalled.length) {
            // 2. Install plugins needed
            logger.info(`Attempting to install ${chalk.yellow(uninstalled.length)} missing plugins`);
            await installHandler(uninstalled.map(([p]) => p));            // // 3. Re-attempt loading
            // 2. Re-attempt to load plugins
            await loadPlugins(uninstalled, true);
          }
        } catch (e) {
          rej(e);
        }
      }

      try {
        await this._checkRequired();
      } catch (e) {
        return rej(e);
      }

      this._buildData = {
        // entities: this._get('entities')!,
        resolvers: this._get('resolvers')!,
        scalars: this._get('scalars')!,
        middlewares: this._get('middlewares')!,
        contextMiddlewares: this._get('contextMiddlewares')!,
        authCheckers: this._get('authCheckers')!
      };
      res(this._buildData);
      this._building = null;
    });
  }

  static clear() {
    this._buildData = undefined;
    this._plugins = {};
  }

  /**
   * Loop over all plugins and check that the dependencies are installed
   */
  private static async _checkRequired() {
    return await Promise.all(Object.values(this._plugins).map(async p => {
      if (!p.requires) return;
      await Promise.all(
        p.requires.map(async required => {
          // TODO: Install required plugin automatically
          if (!this._plugins[required]) throw new ErrorRequiredPluginMissing(p.package, required);
        })
      );
    }));
  }

  /**
   * Combines a key from all plugins
   * @param from Key from each plugin to retrieve
   */
  private static _get<T extends keyof BrixPluginOptions>(from: T) {
    return Object.values(this._plugins).reduce((list, plugin) => {
      if (plugin[from]) return (list as any).concat(plugin[from]);
      return list;
    }, [] as unknown as BrixPluginOptions[T]);
  }
}


global.BrixPlugins = BrixPlugins;
